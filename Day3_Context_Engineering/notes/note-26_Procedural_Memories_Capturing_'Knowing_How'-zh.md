```markdown
### 🎙️ 第 26 頁：Procedural_Memories_Capturing_'Knowing_How'

#### 【本頁重點摘要】
*   程序性記憶是關於「如何做」(knowing how)，而非我們之前討論的「知道什麼」(knowing what)。
*   它的目標不是檢索一個「事實」，而是檢索一個指導代理人執行複雜任務的「計畫」或「劇本」。
*   這本質上是一個「推理增強 (reasoning augmentation)」問題，而非「資訊檢索」問題。
*   與緩慢、離線的「微調 (Fine-tuning)」不同，程序性記憶透過「情境中學習 (in-context learning)」實現快速、線上的適應。

---

#### 【逐字講稿】

(開場白)
好的，到目前為止，我們討論的記憶，絕大多數都屬於「宣告式記憶」，也就是讓代理人記住「事實」、「數據」和「用戶偏好」——簡單來說，就是「知道什麼」。但現在，我們要探討一個更進階、也更能體現代理人智慧的概念：程序性記憶，也就是「知道如何做」。

##### ① 目標不同：檢索「計畫」，而非「事實」
首先，我們必須理解程序性記憶的根本目標。它不是為了回答一個關於「是什麼」的問題，而是為了回答一個「該如何做」的問題。

> 當代理人需要執行一個複雜的任務時，程序性記憶系統的目標，不是去資料庫裡找一個相關的「事實」，而是去找到一份完整的「計畫 (plan)」或「劇本 (playbook)」，這份劇本會一步步指導代理人該如何行動。

這就像一個新手廚師，他需要的不是一本食材百科全書（宣告式記憶），而是一份詳細的食譜（程序性記憶）。

##### ② 本質差異：「推理增強」，而非「資訊檢索」
這個目標上的差異，也決定了它的本質。我們必須強調，程序性記憶是一個**推理增強 (reasoning augmentation)** 的問題，而不是一個**資訊檢索 (information retrieval)** 的問題。

宣告式記憶，是把「資訊」檢索出來，放進上下文，讓模型去**推理**這些資訊。而程序性記憶，是把一個「推理的過程」或「成功的策略」本身檢索出來，讓模型去**遵循**這個過程。這是在更高維度上引導模型的行為。

##### ③ 專屬的生命週期
正因為目標和本質都不同，管理「如何做」的知識，自然需要一套完全不同的演算法生命週期。

*   它的**提取 (Extraction)**，不是捕捉事實，而是從一次成功的互動中，提煉出一個可重複使用的「策略」。
*   它的**整合 (Consolidation)**，不是合併相關事實，而是去管理和優化這些「工作流程」，比如更新一個既有的最佳實踐，或修補一個計畫中的瑕疵步驟。
*   它的**檢索 (Retrieval)**，目標也不是找最相關的資料，而是找到最適合當前任務的「計畫」。

##### ④ 與「微調 (Fine-Tuning)」的比較
談到讓代理人「學習如何做」，很多人會立刻想到「微調」。這兩者都旨在改善代理人的行為，但它們的機制和應用場景截然不同。

> **微調**，像是一個緩慢的、離線的訓練過程，它會直接改變模型底層的權重。這就像是把一個人的性格徹底重塑，耗時且成本高昂。
>
> 而**程序性記憶**，提供的是一種快速、線上的適應能力。它不改變模型本身，而是在每次互動中，動態地將正確的「劇本」注入到提示中，透過我們之前提過的「情境中學習 (in-context learning)」，來即時指導代理人。這更像是在特定情境下，給這個人一本操作手冊，讓他立刻知道該怎麼做。

---

#### 【講者提示 & 轉場】
*   **節奏提醒**：這是一個比較抽象但非常重要的概念。可以放慢速度，特別是在解釋「推理增強」與「資訊檢索」的區別時，確保聽眾能跟上從「提供數據」到「提供方法」的思維轉變。
*   **強化類比**：「廚師與食譜」或「教練給球員戰術手冊 (playbook)」的類比非常有效，可以在演說中多加利用，幫助聽眾理解。
*   **轉場橋樑 (Bridge)**：
    > 我們已經探討了宣告式記憶和程序性記憶這兩種強大的機制，它們分別讓代理人學會了「知道什麼」和「知道如何做」。但無論我們的記憶系統設計得多麼精巧，我們怎麼能確定它真的有效？它記住的東西是對的嗎？它能在需要時準確找到嗎？這就帶我們進入下一個至關重要的主題：如何科學地「測試與評估」我們的記憶系統。
```
### 🎙️ 第 21 頁：Triggering_Memory_Generation

#### 【本頁重點摘要】
*   何時觸發記憶生成，是一個在「資料新鮮度」、「成本」與「延遲」之間取得平衡的關鍵架構決策。
*   常見的觸發策略包含：在對話結束時、按固定頻率（如每 N 次對話）、即時（每次對話後）、或由使用者下達明確指令。
*   最進階的模式是「記憶即工具 (Memory-as-a-Tool)」，也就是讓代理人 (Agent) 自主判斷何時該呼叫工具來儲存記憶。

---

#### 【逐字講稿】

(開場白)
好，我們已經了解了記憶的生成是一個強大的自動化流程。但一個非常實際的問題是：這個流程到底應該「何時」啟動？這不是一個無關緊要的細節，而是一個核心的架構選擇，它直接決定了你的代理人記憶有多即時、營運成本有多高，以及使用者感受到的延遲有多久。

這頁投影片，我們就來探討幾種主流的觸發策略，以及它們各自的權衡。

##### ① 對話完成時 (Session Completion)
這是最簡單直接的方法。我們等到一整段對話完全結束後，再把整個對話紀錄丟給記憶管理器去處理。

> 這就像我們下班後，才一次性地整理今天一整天辦公桌上的所有文件。它的好處是**成本效益最高**，因為你只執行了一次昂貴的生成流程。但缺點是**保真度 (fidelity) 較低**，因為 AI 需要一次消化大量的對話，可能會遺漏掉一些細微的重點。

##### ② 固定頻率觸發 (Turn Cadence)
一個折衷的方案是，設定一個固定的頻率，例如每 5 次或 10 次對話，就觸發一次記憶生成。這就像是每隔一兩個小時，就稍微整理一下桌面。它在成本和資料新鮮度之間取得了不錯的平衡，對於很多應用來說，這是一個「足夠好」的選擇。

##### ③ 即時觸發 (Real-Time)
接著是即時觸發，也就是在每一次對話結束後，立刻生成記憶。這種方式能提供**最高的保真度和最新鮮的記憶**，任何細節都會在發生的當下被捕捉。但可想而知，這也是**成本最高、對系統負擔最大**的選項。如果處理不當，很容易因為等待記憶寫入而增加使用者感受到的延遲。

##### ④ 使用者明確指令 (Explicit Command)
我們也可以把控制權交給使用者。當使用者明確地說出「記住這件事」或類似的指令時，我們才觸發記憶生成。這個方法非常直接，而且能確保被存下來的，絕對是使用者認為重要的資訊。

##### ⑤ 記憶即工具 (Memory-as-a-Tool)
最後，是我們認為最進階，也最能體現「代理人」智慧的模式：「記憶即工具」。在這種模式下，我們不再設定寫死的規則，而是把「生成記憶」這件事，包裝成一個代理人可以呼叫的工具，例如 `create_memory`。

> 然後，我們**授權代理人自己去分析對話**，當它判斷當前的資訊具有長期保存的價值時，由它**自主決定**去呼叫這個工具。這就把觸發的責任，從開發者寫死的規則，轉移到了代理人自身的智慧判斷上。

---

#### 【講者提示 & 轉場】
*   **節奏提醒**：在介紹這幾種策略時，可以畫一個三角形，三個頂點分別是「成本」、「延遲」和「保真度」。強調每種策略都是在這個三角形上的不同取捨點。
*   **補充案例**：可以補充說明，沒有哪種策略是絕對最好的，完全取決於應用場景。例如，一個需要高度個人化的心理諮詢代理人，可能傾向於即時觸發；而一個普通的問答機器人，或許在對話結束時觸發就足夠了。
*   **轉場橋樑 (Bridge)**：
    > 剛剛提到的最後一點，「記憶即工具」，是一個非常強大的設計模式。它代表了一種趨勢，也就是讓代理人從一個只會遵從指令的程式，進化成一個能自主管理其知識的智慧體。下一頁，我們將深入探討這個進階模式，看看它是如何運作的，以及它為我們帶來了哪些好處。
### 🎙️ 第 24 頁：Timing_for_Retrieval_Proactive_vs._Reactive

#### 【本頁重點摘要】
*   記憶檢索的時機，是在「延遲」與「情境完整性」之間的關鍵權衡。
*   主要有兩種策略：主動式檢索 (Proactive)，每次都預先載入；以及反應式檢索 (Reactive)，在需要時才由代理人決定去查詢。
*   主動式雖然確保資訊隨時可用，但可能造成不必要的延遲；反應式更有效率，但增加了決策的複雜性。

---

#### 【逐字講稿】

(開場白)
好，我們已經知道如何設計一個好的檢索策略，來找出最相關的記憶。但下一個關鍵的架構問題是：**到底該在「什麼時候」去執行這個檢索動作？** 這是一個非常重要的決定，它會直接影響到我們代理人的反應速度和智慧程度。

這頁投影片就為我們展示了兩種截然不同的哲學：主動式與反應式。

##### ① 第一種策略：主動式檢索 (Proactive Retrieval)，或稱為「積極型」
這個策略非常直接。它的做法是，在**每一次**對話開始時，就自動去記憶庫裡把相關的記憶撈出來，準備好。

> 這就像一位極度殷勤的助理。在你跟任何人開會前，他都會把所有可能用到的檔案、過去的會議記錄，全部攤在桌上，以防萬一。

*   **優點**很明顯：**情境永遠都在**。代理人隨時都處於「準備好」的狀態，不會因為缺少資訊而措手不及。
*   但**缺點**也同樣致命：**延遲**。在很多對話回合中，代理人根本不需要參考過去的記憶。這種「過度準備」會導致不必要的計算和等待，讓使用者感覺代理人反應很慢、很卡。

##### ② 第二種策略：反應式檢索 (Reactive Retrieval)，也稱為「懶人型」或「工具型」
這個方法就聰明多了。我們不讓系統每次都傻傻地去撈資料，而是把「查詢記憶」這件事，本身變成一個**工具**，交給代理人自己。

> 回到剛剛的助理比喻。這次，助理不會主動攤開所有文件。他會靜靜地站在一旁，直到你問：「嘿，我們上次討論那個專案的結論是什麼？」這時，他才會去檔案櫃裡，精準地找出那份文件給你。

*   **優點**是**高效率**。只有在代理人（也就是 LLM）判斷當前對話確實需要參考過去的記憶時，才會觸發檢索動作。這大大降低了不必要的延遲，讓互動更流暢。
*   但它也有**挑戰**。首先，代理人「決定」要使用這個工具，本身就需要一次額外的 LLM 推理，這會增加一點點成本和延遲。更重要的是，代理人**可能根本不知道有相關的資訊存在**。就像你如果忘了自己有做過某份會議記錄，你自然也想不到要去查詢它。不過，我們可以透過在工具的描述中，提示代理人「記憶庫裡可能有哪些類型的資訊」，來稍微緩解這個問題。

---

#### 【講者提示 & 轉場】
*   **節奏提醒**：講完這兩種策略後，可以停頓一下，強調這是一個「沒有標準答案」的設計抉擇。開發者需要根據應用的情境（例如，是需要極快反應，還是需要極度周全）來做權衡。
*   **強化比喻**：「積極型」就像一位過度準備的助理，保證萬無一失但有點囉嗦；「反應式」則像一位更聰明、更懂得察言觀色的專家，只在關鍵時刻出手。
*   **轉場橋樑 (Bridge)**：
    > 所以，無論我們是積極地預先載入記憶，還是被動地等代理人自己去查詢，一旦我們拿到了這些寶貴的記憶，下一個問題就來了：我們該如何把它們呈現給模型呢？是把它當成最高機密的「系統指令」偷偷塞進去，還是把它當成一段對話，直接插入到歷史紀錄中？這兩種不同的「放置」方式，會對模型的思考產生截然不同的影響。下一頁，我們就來探討這個問題。
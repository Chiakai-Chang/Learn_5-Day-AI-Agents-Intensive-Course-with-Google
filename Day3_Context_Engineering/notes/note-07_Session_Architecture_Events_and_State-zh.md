```markdown
### 🎙️ 第 07 頁：Session_Architecture_Events_and_State

#### 【本頁重點摘要】
*   一個 Session 由兩個核心組件構成：**事件 (Events)** 與 **狀態 (State)**。
*   **事件**是依時間順序記錄的對話歷史，包含使用者輸入、模型回應、工具調用與工具輸出。
*   **狀態**是暫時性的工作記憶，用來存放當前對話的結構化資料，例如購物車裡的商品。

---

#### 【逐字講稿】

(開場白)
好的，我們剛剛把 Session 比喻成一個專案的工作檯。現在，讓我們來仔細看看這個工作檯上到底放了些什麼東西。一個 Session 的架構，主要由兩個關鍵部分組成：**事件 (Events)** 和 **狀態 (State)**。

##### ① 第一個是「事件」，也就是對話的時序歷史 (Chronological History)
你可以把「事件」想像成這場對話的每一個積木，它們按照發生的順序一個個堆疊起來，構成完整的互動記錄。

這包含了幾種核心類型：
*   **使用者輸入 (User Input)**：就是使用者說的話、問的問題。
*   **模型回應 (Agent Response)**：我們 AI Agent 的回覆。
*   **工具調用 (Tool Call)**：當 Agent 決定需要使用外部工具來完成任務時，這個「決定」本身就是一個事件。
*   **工具輸出 (Tool Output)**：外部工具回傳的資料或結果，Agent 會根據這個結果繼續下一步的思考。

> 如果你熟悉 Gemini API，這個結構就非常直觀了。它就像是傳遞給 Gemini API 的 `Content` 物件列表，每一個物件都標明了是誰 (`role`) 說了什麼 (`parts`)，完整記錄了你來我往的每一回合。

##### ② 第二個是「狀態」，也就是我們所說的「工作記憶 (Working Memory)」
如果說「事件」是完整的對話錄音稿，那麼「狀態」就是 Agent 放在旁邊的一張結構化的便利貼或草稿紙 (Scratchpad)。

它專門用來存放**和當前這次對話高度相關的、暫時性的資料**。最經典的例子就是購物車。當你請 AI 幫你把商品加入購物車時，「購物車裡有哪些商品」這個列表，並不是對話的一部分，但卻是完成這次購物任務至關重要的資訊。這個列表就會被存放在 Session 的「狀態」裡。當對話結束，這個暫時的狀態通常也就不再需要了。

---

#### 【講者提示 & 轉場】
*   **節奏提醒**：講完這兩個概念後，可以稍微停頓一下，確保聽眾理解「事件」是歷史紀錄，而「狀態」是暫存資料這兩個核心區別。
*   **補充案例**：如果時間允許，可以再舉一個「狀態」的例子，例如：在一個多步驟的機票預訂流程中，「狀態」可以儲存使用者已經確認的出發地、目的地和日期，即使對話中間聊了別的話題，這些核心資訊也不會遺失。
*   **轉場橋樑 (Bridge)**：
    > 了解了單一 Agent 的對話是如何被結構化的，下一個問題自然就是：如果系統中不只有一個 Agent 呢？當多個 Agent 需要協同工作時，它們之間是如何共享或隔離這些對話歷史的？下一頁，我們就來探討多 Agent 系統中的 Session 管理模式。
```
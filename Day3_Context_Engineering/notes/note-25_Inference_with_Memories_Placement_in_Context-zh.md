### 🎙️ 第 25 頁：Inference_with_Memories_Placement_in_Context

#### 【本頁重點摘要】
*   成功檢索到記憶後，我們必須決定將它放在提示 (Prompt) 中的哪個位置。
*   主要有兩種策略：放入「系統指令」中，賦予其高權威性；或注入「對話歷史」中，使其更貼近當前上下文。
*   兩種方法各有優劣，最佳實踐通常是混合使用。

---

#### 【逐字講稿】

(開場白)
好，我們前面討論了如何產生記憶、如何檢索記憶。現在，我們來到了最後，也是至關重要的一步。我們已經從記憶庫中找到了最相關的資訊，但問題是... **我們該把這些記憶放在提示 (Prompt) 的哪個位置，才能讓模型最有效地利用它呢？** 這不是一個隨意的決定，放錯位置可能會讓模型混淆，甚至產生反效果。

這頁投影片，我們就來探討兩種最主流的策略。

##### ① 第一種策略：放在系統指令 (System Instructions) 中
這可以說是最直接的方法。我們把檢索到的記憶，直接附加到系統指令的後面。你可以把它想像成，在 AI 開始對話前，我們先遞給它一份關於這位用戶的「個人檔案」或「背景提要」。

> 這種做法會賦予這些記憶非常高的**權威性**。模型會把它們當作是這次互動最核心、最基礎的背景知識。這非常適合用來放置那些穩定、全域性的資訊，比如用戶的個人資料、固定的偏好設定等等。

然而，這種方法也有幾個明顯的缺點。首先是**過度影響 (over-influence)** 的風險。因為這些記憶在系統指令中的地位太高，模型可能會過度解讀，試圖把所有話題都跟這些記憶扯上關係，即便有時候並不合適。其次，這個方法與我們之前提到的「記憶即工具 (Memory-as-a-Tool)」模式是**不相容的**。因為系統指令必須在模型決定是否要呼叫工具之前就準備好。

##### ② 第二種策略：注入對話歷史 (In the Conversation History)
另一種方法，是將記憶動態地注入到一來一往的對話歷史當中。這就像是在對話進行到一半時，悄悄地遞給 AI 一張「小紙條」，提醒它一些相關的資訊。

這種方式最常見的實現，就是透過「工具呼叫」的結果。當代理人決定使用 `search_memory` 這個工具時，檢索到的記憶就會以工具輸出的形式，自然地出現在對話記錄裡。

> 這種策略非常適合處理那些**短暫的、片段式的記憶**，也就是只跟當前對話上下文高度相關的資訊。

但它的挑戰也不少。首先，它可能會讓對話歷史變得很「吵雜」，增加 token 成本。如果檢索到的記憶不夠精準，反而會干擾模型的判斷。最大的風險在於所謂的「**對話注入 (dialogue injection)**」，模型可能會誤以為這段記憶是某個人 (用戶或它自己) 真的在對話中說過的話，從而做出不自然的回應。

*   舉個例子，如果你注入了一條記憶「事實：用戶喜歡喝咖啡」，模型可能會回覆：「你剛剛告訴我你喜歡喝咖啡」，這聽起來就很奇怪。因此，我們必須非常小心記憶的措辭和視角。

在實務上，最好的方法往往是**混合使用**這兩種策略：用系統指令來存放穩定、全域的用戶輪廓；同時，用注入對話歷史的方式，來處理與當前任務相關的動態、情境式記憶。

---

#### 【講者提示 & 轉場】
*   **節奏提醒**：講完這兩種策略後，可以稍微停頓，讓聽眾思考一下這兩種方法的根本差異：「事前給予的背景檔案」 vs. 「事中傳遞的小紙條」。
*   **補充案例**：可以舉例，像用戶的姓名、會員等級，就適合放在系統指令；而用戶上一輪對話提到的「想找藍色的外套」，就適合當作工具輸出的結果注入對話歷史。
*   **轉場橋樑 (Bridge)**：
    > 到目前為止，我們討論的所有記憶——無論是事實、偏好還是歷史——都屬於「陳述性記憶 (declarative memories)」，也就是「知道**什麼** (knowing what)」。但如果一個代理人需要記住的是「**如何** (knowing how)」去完成一個任務呢？這就引導我們進入一個更進階、也更強大的記憶類型。下一頁，我們就來探討「程序性記憶」。
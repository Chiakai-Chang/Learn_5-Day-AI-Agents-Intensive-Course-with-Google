### 🎙️ 第 05 頁：The_Context_Engineering_Lifecycle

#### 【本頁重點摘要】
*   本頁說明了「情境工程」在每一次對話中運作的連續循環。
*   這個循環包含四個關鍵階段：獲取情境、準備情境、調用模型與工具，以及上傳情境。
*   強調了哪些步驟是「阻塞式」的（必須等待完成），哪些是「非阻塞式」的（在背景中進行）。

---

#### 【逐字講稿】

(開場白)
好的，我們已經理解了「情境工程」就像是廚師在料理前的備料（Mise en Place）。現在，讓我們來看看這位 AI 大廚在每一次與使用者互動時，實際上是如何一步步「烹飪」的。這就是「情境工程生命週期」，一個在每次對話中不斷重複的循環。

##### ① 第一步：獲取情境 (Fetch Context)
首先，是**獲取情境**。這就像廚師從冰箱和儲藏室裡拿出所有需要的食材。AI 代理會開始檢索所有相關的資訊，例如關於這位使用者的**長期記憶**、從外部知識庫（也就是 RAG）中找到的相關文件，以及我們這次對話最近的幾句交談紀錄。

> 值得注意的是，這是一個動態的過程。代理會根據你當前問的問題，來決定要去檢索哪些最相關的資訊。

##### ② 第二步：準備情境 (Prepare Context)
拿到所有材料後，就進入了至關重要的第二步：**準備情境**。代理框架會將剛剛獲取的所有資訊——系統指令、工具、記憶、RAG 文件、對話歷史——動態地組合成一個完整的、結構化的提示 (Prompt)，準備提交給大型語言模型。

這個步驟被稱為「**阻塞式 (Blocking)**」或「**熱路徑 (Hot-Path)**」流程。這意味著代理必須等所有情境都準備就緒後，才能進行下一步。它不能在材料還沒備齊的時候就開始炒菜。

##### ③ 第三步：調用大型語言模型與工具 (Invoke LLM and Tools)
情境準備好之後，就進入了執行階段。代理會**迭代地 (iteratively)** 調用大型語言模型和它所需要的任何工具，直到生成最終要給使用者的回覆。這個過程可能不是一次就完成的，而是來來回回的思考、調用工具、再思考，直到得出結論。所有工具和模型的輸出，又會被加回到當前的情境中。

##### ④ 第四步：上傳情境 (Upload Context)
最後，當代理把回覆傳送給使用者後，它會在**背景 (background)** 中進行最後一個步驟：**上傳情境**。在這次對話中產生的任何新資訊，例如新的記憶點，都會被非同步地（asynchronously）上傳到持久化的儲存空間。

> 這樣做的好處是，使用者可以立刻收到回覆，而不需要等待代理完成歸檔工作。這確保了流暢的使用者體驗，同時也讓代理的知識庫不斷成長。

---

#### 【講者提示 & 轉場】
*   **節奏提醒**：講完這四個步驟後，可以稍微停頓一下，讓聽眾消化這個循環的流程。這是一個核心概念。
*   **補充說明**：可以再次使用廚師的類比來總結——「獲取食材、準備食材、烹飪、最後清洗和歸檔」。
*   **轉場橋樑 (Bridge)**：
    > 了解了這個為每一次互動精心準備情境的生命週期後，你可能會好奇：這整個對話的「容器」是什麼？這個管理著所有即時互動歷史的工作台，就是我們的第一個核心組件——**Session**。下一頁，我們就來深入探討它。
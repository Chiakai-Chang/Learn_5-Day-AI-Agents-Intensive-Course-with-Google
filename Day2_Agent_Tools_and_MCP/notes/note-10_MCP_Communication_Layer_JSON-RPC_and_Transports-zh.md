```markdown
### 🎙️ 第 10 頁：MCP Communication Layer: JSON-RPC and Transports

#### 【本頁重點摘要】
*   MCP 的通訊基礎是 **JSON-RPC 2.0**，這是一種輕量、跨語言的訊息格式。
*   通訊協定定義了四種訊息類型：`請求 (Requests)`、`結果 (Results)`、`錯誤 (Errors)` 和 `通知 (Notifications)`。
*   MCP 支援兩種主要的「傳輸協定」：用於本機溝通的 `stdio` 和用於遠端連接的 `Streamable HTTP`。

---

#### 【逐字講稿】

(開場白)
好，我們剛剛看過了 MCP 的三大核心組件：Host、Client 和 Server。現在，讓我們來揭開它們之間是如何進行溝通的神秘面紗。這一切都建立在一個標準化、且非常穩固的技術基礎之上。

##### ① 訊息的「語言」：JSON-RPC 2.0
首先，我們需要一種所有組件都能聽懂的「共同語言」。在 MCP 的世界裡，這個語言就是 **JSON-RPC 2.0**。

> 你可以把它想像成 MCP 溝通的「語法書」。它非常輕量、易於閱讀，而且最重要的是，它與任何程式語言都無關。這意味著一個用 Python 寫的 Client，可以和一個用 Go 語言寫的 Server 完美對話，完全沒有障礙。

這個語法書定義了四種基本的對話模式：
*   **請求 (Requests)**：就像 Client 對 Server 說：「嘿，請幫我執行這個工具。」
*   **結果 (Results)**：Server 回應：「沒問題，這是你想要的結果。」
*   **錯誤 (Errors)**：Server 說：「糟糕，執行失敗了，這是錯誤訊息。」
*   **通知 (Notifications)**：這是一種單向的訊息，像是 Server 主動告訴 Client：「我這裡更新了工具列表喔！」它不需要對方回應。

##### ② 訊息的「快遞」：傳輸協定 (Transports)
有了共同語言還不夠，我們還需要可靠的「快遞服務」來傳遞這些訊息。MCP 主要定義了兩種傳輸協定，大家可以對照螢幕上的圖來看。

*   **第一種是 `stdio`，也就是標準輸入輸出。**
    這條路徑專為**本機溝通**設計。想像一下，當 MCP Server 作為 Host 應用程式的一個子進程在同一台電腦上運行時，它們之間就可以透過 `stdio` 進行極速、直接的溝通。這非常適合需要存取本機資源的場景，例如讀取你電腦上的檔案系統。

*   **第二種是 `Streamable HTTP`。**
    這是 MCP **推薦用於遠端連接**的協定。當你的 AI 應用需要和網路另一端的 Server 溝通時，就會走這條路。它不僅支援高效的串流式回應 (SSE)，讓 Server 可以持續回傳進度，而且設計上也可以支援無狀態 (stateless) 的伺服器架構，讓系統更容易擴展。

---

#### 【講者提示 & 轉場】
*   **節奏提醒**：在解釋兩種傳輸協定時，可以用手勢指向螢幕上的圖表，分別對應「Local」和「Remote」的路徑，幫助聽眾視覺化。
*   **補充說明**：可以強調，這種標準化的分層設計（訊息格式 vs. 傳輸方式）是 MCP 能夠兼具彈性與互通性的關鍵。
*   **轉場橋樑 (Bridge)**：
    > 了解了 MCP 如何建立溝通的「語言」和「管道」之後，下一個問題自然是：它們到底在溝通些「什麼」？下一頁，我們將深入探討 MCP 定義的核心概念，也就是所謂的「基元 (Primitives)」，其中最重要的，就是「工具 (Tools)」。
```
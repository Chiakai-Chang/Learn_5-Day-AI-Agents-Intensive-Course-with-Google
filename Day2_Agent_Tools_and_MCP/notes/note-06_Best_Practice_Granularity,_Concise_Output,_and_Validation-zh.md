```markdown
### 🎙️ 第 06 頁：Best_Practice_Granularity,_Concise_Output,_and_Validation

#### 【本頁重點摘要】
*   **工具的顆粒度**：工具應該遵循「單一職責原則」，每個工具只做一件事，避免設計成複雜的「萬能工具」。
*   **精簡的輸出**：工具的回應應盡量簡潔，避免返回大量數據，以免佔用寶貴的上下文視窗、增加成本與延遲。
*   **有效的驗證**：利用 Schema 驗證工具的輸入與輸出，這不僅能確保執行安全，也能作為給 LLM 的另一種文件，幫助它正確使用工具。

---

#### 【逐字講稿】

(開場白)
好，我們剛剛談完了如何「描述」我們的工具，讓模型能聽得懂。但光有好的文件還不夠，工具本身的「設計」才是決定一個 Agent 系統是「堪用」還是「卓越」的關鍵。接下來這三點，就是我們在打造工具時，必須遵守的黃金法則。

##### ① 法則一：讓工具保持「小而美」，也就是顆粒度要細
這其實是借鏡了軟體工程中的一個核心概念，叫做「單一職責原則」。簡單來說，就是一個工具只做一件事情，而且要把它做好。

我們應該避免去創造一個什麼都能做的「萬能工具」，因為這種工具通常很複雜，文件難寫，模型也很難判斷到底該在什麼時候使用它。

> 把你的工具想像成一套專業的廚房刀具組，有切肉刀、水果刀、麵包刀... 而不是一把笨重的瑞士刀。每一把刀都有它最適合的場景，模型才能精準地選用。

當然，有時候一個常見的工作流程可能需要很多步驟，這時或許可以把它包成一個工具，但這種情況下，你的文件就必須寫得「極度清晰」，讓模型毫不費力地理解這個工具的完整功能。

##### ② 法則二：設計「精簡的」輸出
這是 Agent 系統中一個最常見的效能殺手：話太多的工具。當一個工具返回大量的數據，比如好幾千行的表格、整個檔案的內容、或是高解析度的圖片時，會發生什麼事？

這些龐大的回應會嚴重「污染」模型的上下文視窗。這不僅會大幅增加 API 的呼叫成本和延遲，更糟的是，它會擠掉其他重要的對話歷史或指令，導致模型的推理能力下降，變得「健忘」或「困惑」。

所以，**千萬不要直接返回龐大的數據**。正確的做法是利用外部系統。例如，與其返回一個巨大的查詢結果，不如將結果存入一個暫存的資料庫表格，然後只返回這個表格的名稱。這樣，後續的工具就可以直接從資料庫讀取，完全不佔用模型的思考空間。像 Google ADK 框架裡的 Artifact Service 就是專門為此設計的。

##### ③ 法則三：善用「驗證」機制
現在大多數的工具框架都支援對工具的「輸入」和「輸出」進行 Schema 驗證，我們應該盡可能地使用這個功能。

這件事有兩個非常重要的作用。首先，它是一個執行時的安全檢查，確保模型沒有傳入錯誤的參數，保護了我們的後端系統。但更重要的是第二點：

> Schema 本身就是一種「文件」。它用一種結構化的方式，再次向 LLM 確認了這個工具需要什麼、會返回什麼，讓模型能更準確地呼叫它。

一個定義清晰的輸入和輸出 Schema，就像是給工具上了一份雙重保險，既能保護系統，又能引導模型。

---

#### 【講者提示 & 轉場】
*   **節奏提醒**：講完這三點後，可以稍微停頓一下，讓聽眾消化一下。這三點是從「單一工具設計」角度出發最重要的實踐。
*   **補充案例**：如果時間允許，可以補充一個「描述性錯誤訊息」的技巧。例如，當工具出錯時，不要只返回 `Error 500`，而是返回像「找不到這個產品 ID，請跟客戶確認產品名稱，並用名稱重新查詢 ID」這樣的指導性訊息，這能幫助 Agent 自我修正。
*   **轉場橋樑 (Bridge)**：
    > 好的，到目前為止，我們已經學會如何設計出清晰、高效、且安全的「單一」工具。但現實世界中，一個強大的 Agent 不會只有一個工具，它可能有幾十個，甚至幾百個。當工具數量爆炸性增長時，我們又該如何管理這種複雜性呢？這就帶出了我們下一個要探討的巨大挑戰——「N x M 整合問題」。
```